# Reflection:

## Question:

Over the course of the term, you have been exposed to a variety of data structures. Considering the functionality of a Trie, pick another 2 other data structure we have studied and discuss the following: - how good will that data structure be at the tasks (search, begins_with and insert) that a Trie can do. To get full marks on this discussion, please provide details about the data structure you are comparing with the Trie, its features, and how well is it able to handle each of the three tasks of the Trie.

## Answer:

Trie has many advantages and disadvantages compared to other data structures which is interesting to look at and in this reflection i'm going to compare it to hash table and a binary search tree. One advantage is that the insert and search algorithm have the best time complexity of O(n), which is faster than even the best case scenerio of a binary search tree (BST). Furthermore, when we look up a string for a hash table, we first have to calculate the hash value of the string, which takes O(n) time. Then, it will take O(1) time to locate it in the memory. Therefore, the overall lookup time complexity is O(n) for a hash table. However, when we lookup a string for a trie, we go through each character of the string and locate its corresponding node in the trie. The overall lookup time complexity is O(n). Howevever, the trie has some more elevation to retrieve the whole string because we needs moree memory to search multiple times and locate the trie nodes with each character path. Nevertheless, for the hash table, we only need to compute the hash value for the input string once which is faster when we lookup a whole string. 

Also, in this assignment it was much simplier to sort and print in an alphabetical order with the begins_with and search functions for the most part, however this is more difficult if we are using the hashing method. On the other hand, in a hash table we always compute the hash value for the whole input string whether the string exists in the hash table or not. But for the trie, if we don't find a matching character then the search stops early. Therefore, the lookup speed could be faster for the trie if the input string doesn't exist in the trie.

As well as, the prefix search is easily doable. However a lot of memory is used in storing the pool of strings in a Trie, and when data keeps getting inserted, the space complexity explodes. This can similarily be compared to when we learned about heap removals and that when a value gets removed it doesn't technically leave the array and instead will hold the space. This is because we can't change the storage in an array.

A BST is typically used to store numerical values. The time complexity in a BST is O log(n) for search, begins_with and insert. Each node in a binary tree has at most 2 child nodes. However for a Trie, every node of trie consists of multiple branches. Each branch represents a possible character of keys. The last node of every key as leaf node gets marked. A trie node field value will be used to distinguish the node as a leaf node.

Tries also have specific features when they want to insert, search or begin_with can be quicker than a BST. In a trie, the search function or looking up keys or length is faster therfore, the time complexity would be O(n avgL), where 'n' is the number of strings we want to insert in Trie and 'avgL' is the average length of 'n' strings as my best assumption. However for a BST which we have learned performs a O log(n) comparison of keys, because lookups depend on the depth of the tree, which is logarithmic in the number of keys if the tree is balanced. Therefore, in the worst case scenerio, a BST takes O(m log n) in time complexity. Also, the simple operations tries use during lookup, such as array indexing using a character, are fast on real machines.

Tries also seem to be more space efficient when they contain a large number of short keys compared to a BST because nodes are shared between keys with common initial subsequences. Tries also facilitate the longest prefix matching, helping to find the key sharing the longest possible prefix of characters all unique. 

In conclusion, all data structures are great and useful depending on what your goal is to acheive. A balanced tree should almost always be a better choice then a regular BST. Hash table is a good choice when you want average short time, but do not care that some times you will have performance loss due to rehash, and in some cases collisions may occur. Trie is usually a good dictionary for strings.